<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于泛型]]></title>
    <url>%2F%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[关于泛型[TOC] 1.为什么需要泛型1.1 使用集合时可能会发生安全的问题：可以向集合中放入任何类型1.2 麻烦：从集合中获取元素,需要进行类型的强制转换2.使用泛型：使用泛型方法、泛型类 3.定义泛型3.1：定义泛型类： 按照规则来定义3.1.1 声明类(接口)时,在类名的后面,大括号的前面利用&lt;&gt; 来声明泛型。在类中凡是可以使用类型的地方都可以使用类中声明的泛型.1public class Dao&lt;T&gt; 3.2：定义泛型方法3.2.1 在类(不一定是泛型类)中使用泛型方法.3.2.2 在方法的返回值前面使用 &lt;&gt; 声明泛型类型，则在方法的返回值,参数,方法体中都可以使用该类型4.通配符4.1 如果Foo是Bar的一个子类型(子类或接口),而G是某种泛型声明.1234那么G&lt;Foo&gt;是G&lt;Bar&gt;的子类型并不成立:Person 是Object的子类,但List&lt;Person&gt;却不是List&lt;Object&gt;的子类！printPersons(List&lt;Person&gt; persons); 该方法的参数只能是Person类型的List,而不能是Person 任何子类的List,例如Student类型的ListCollection&lt;?&gt; 4.2 Collection&lt;?&gt;4.2.1 它的元素类型可以匹配任何类型. ? 被称为通配符.4.2.2 将任意元素加入其中不是类型安全的,null除外！ 因为null 可以是任何类型4.3 Collection&lt;? extends Person&gt;为带上限的通配符：该类型可以指向Person类型及Person子类类型的集合。但，也不能向其中放null以外的任何元素.]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo入门事件---搭建一个最简单的Demo框架]]></title>
    <url>%2FDubbo.html</url>
    <content type="text"><![CDATA[Dubbo背景和简介背景 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构当网站流量很小时，只需要一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM)是关键 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小,将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架（MVC）是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立服务，逐渐形成稳定的服务中心，使前端应用能快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。 流动计算构架当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。 关于RPC的简介：RPC(Remote Procedure Call Protocol)：远程过程调用：两台服务器A、B，分别部署不同的应用a，b。当A服务器想要调用B服务器上应用b提供的函数和方法的时候，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义传达调用的数据。 直白的说就是，你在你的机器上写了一个程序，我这边是无法直接调用的 ，这个时候就出现了一个远程调用的概念。 RPC是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。 RPC需要解决的问题： 通讯问题：主要是通过在客户端和服务端之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。 寻址问题：A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。 序列化和反序列化：当A服务器上的应用发起远程调用时，方法的参数需要通过底层的网络协议如TCP 传递到B服务器，由于网络协议是基于二进制，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址好传输将序列化的二进制发送给B服务器。同理，B服务器接收参数要将参数反序列化。B服务器应用调用自己的方法处理后返回的结果也要序列化给A服务器，A服务器接收也要经过反序列化的过程。 Dubbo是什么Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力： 面向接口的远程方法调用 智能容错和负载均衡 服务自动注册和发现。 每天为2千多个服务提供大于30亿次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点以及别的公司的业务中。 Dubbo架构 节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。 连通性 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 健壮性 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 伸缩性 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者 Dubbo注册中心对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。 通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。 Dubbo提供的注册中心有如下几种类型可供选择： Multicast注册中心 Zookeeper注册中心 Redis注册中心 Simple注册中心 Dubbo优缺点 优点： 透明化的远程方法调用 （ 像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。） 软负载均衡及容错机制 ①.可在内网替代nginx lvs等硬件负载均衡器。 服务注册中心自动注册 &amp; 配置管理 ①.不需要写死服务提供者地址，注册中心基于接口名自动查询提供者ip。 ②.使用类似zookeeper等分布式协调服务作为服务注册中心,可以将绝大部分项目配置移入zookeeper集群。 服务接口监控与治理 ①.Dubbo-admin与Dubbo-monitor提供了完善的服务接口管理与监控功能，针对不同应用的不同接口，可以进行 多版本，多协议，多注册中心管理。 缺点： 只支持JAVA语言 Dubbo入门Demo了解了Dubbo以后，自然要搭建一个简单的Demo实现。本文采用Dubbo与Zookeeper、Spring框架的整合 主要是以下几个步骤： 安装Zookeeper后，启动 创建Maven项目，构建Dubbo+Zookeeper+Spring实现的简单Demo； 安装Dubbo-admin，实现监控。 Zookeeper介绍与安装本Demo中的Dubbo注册中心采用的是Zookeeper。为什么采用Zookeeper呢？ Zookeeper是一个分布式的服务框架，是树型的目录服务的数据存储，能做到集群管理数据 ，这里能很好的作为Dubbo服务的注册中心。 Dubbo能与Zookeeper做到集群部署，当提供者出现断电等异常停机时，Zookeeper注册中心能自动删除提供者信息，当提供者重启时，能自动恢复注册数据，以及订阅请求 具体的安装方法在此不一一叙述，可参考博文：http://blog.csdn.net/tlk20071/article/details/52028945 安装完成后，进入到bin目录，并且启动zkServer.cmd，这个脚本中会启动一个java进程：(注：需要先启动zookeeper后，后续dubbo demo代码运行才能使用zookeeper注册中心的功能) 创建Maven项目项目结构：主要分为三大模块：dubbo-api：存放公共接口；dubbo-consumer : 调用远程服务；dubbo-provider： : 提供远程服务。 下面将详细叙述代码构建过程。1）首先构建Maven项目，导入所需要的jar包依赖。 列出详细的pom.xml文件 2）创建dubbo-api的Maven项目(有独立的pom.xml，用来打包供应服务提供者、服务消费者使用)。在项目中定义服务接口：该接口需单独打包，在服务提供方和消费方共享。 1234567891011package com.raven.dubbo.demo;import java.util.List;/** * Created by Raven on 2018年7月12日15:21:31 */public interface DemoService &#123; List&lt;String&gt; getPermissions(Long id);&#125; 3))创建dubbo-provider的Maven项目(有独立的pom.xml，用来打包供消费者使用)。实现公共接口，此实现对消费者隐藏： 1234567891011121314151617181920package com.raven.dubbo.demo.impl;/** * Created by Boy */import com.raven.dubbo.demo.DemoService;import java.util.ArrayList;import java.util.List;public class DemoServiceImpl implements DemoService &#123; @Override public List&lt;String&gt; getPermissions(Long id) &#123; List&lt;String&gt; demo = new ArrayList&lt;String&gt;(); demo.add(String.format("Permission_%d", id-1)); demo.add(String.format("Permission_%d",id)); demo.add(String.format("Permission_%d",id+1)); return demo; &#125;&#125; 在dubbo-provider中的pom.xml文件中加入公共接口所在的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;DubboDemo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 用Spring配置声明暴露服务 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!--定义了提供方应用信息，用于计算依赖关系；在 dubbo-admin 或 dubbo-monitor 会显示这个名字，方便辨识--&gt; &lt;dubbo:application name="demotest-provider" owner="programmer" organization="dubbox"/&gt; &lt;!--使用 zookeeper 注册中心暴露服务，注意要先开启 zookeeper--&gt; &lt;dubbo:registry address="zookeeper://localhost:2181"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!--使用 dubbo 协议实现定义好的 api.PermissionService 接口--&gt; &lt;dubbo:service interface="com.raven.dubbo.demo.DemoService" ref="demoService" protocol="dubbo"/&gt; &lt;!--使用 dubbo 协议实现定义好的 api.PermissionService 接口--&gt; &lt;bean id="demoService" class="com.raven.dubbo.demo.impl.DemoServiceImpl"/&gt;&lt;/beans&gt; 启动远程服务： 123456789101112131415161718192021222324252627package com.raven.dubbo.demo.impl;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * 功能描述:&lt;br&gt; * &lt;服务提供者&gt; * @since: 1.0.0 * @Author:Raven * @Date: 2018/7/17 0017 16:37 */public class Provider &#123; public static void main(String[] args) throws IOException&#123; //读取Provider配置文件 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("provider.xml"); System.out.println(context.getDisplayName()+":here"); //启动容器 context.start(); System.out.println("provider服务已经启动..."); //使线程阻塞 System.in.read(); &#125;&#125; 4)创建dubbo-consumer的Maven项目(可以有多个consumer，但是需要配置好)。 调用所需要的远程服务： 通过Spring配置引用远程服务： 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;dubbo:application name="demotest-consumer" owner="programmer" organization="dubbox"/&gt; &lt;!-- 向zookeeper 订阅provider 的地址，由zookeeper定时推送--&gt; &lt;dubbo:registry address="zookeeper://localhost:2181"/&gt; &lt;!--使用dubbo 协议调用定义好的api.PermissionService--&gt; &lt;dubbo:reference id="permissionService" interface="com.raven.dubbo.demo.DemoService"/&gt;&lt;/beans&gt; 启动Consumer,调用远程服务： 123456789101112131415161718192021222324252627package com.raven.dubbo.consumer;import com.raven.dubbo.demo.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 功能描述: &lt;br&gt; * 〈消费者示例〉 * @param null * @return: * @since: 1.0.0 * @Author:Administrator * @Date: 2018/7/17 0017 16:51 */public class Consumer &#123; public static void main(String[] args) &#123; //读取配置文件 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("consumer.xml"); context.start(); System.out.println("consumer start"); //获取在zookeeper注册的服务接口 DemoService demoService = context.getBean(DemoService.class); System.out.println("consumer"); System.out.println(demoService.getPermissions(1L)); &#125;&#125; 5）运行项目，先确保provider已被运行后再启动consumer模块： 运行提供者： 消费者成功调用提供者所提供的远程服务： Dubbo管理控制台介绍下载dubbo-admin可自行根据网上介绍安装,安装使用方法dubbo-admin是阿里巴巴的发布的dubbo管理平台。官方下载地址：https://github.com/alibaba/dubbo我用的2.6.0下载incubator-dubbo-dubbo-2.6.0版本. 将下载好的压缩包解压，进入dubbo-admin-2.6.0/WEB-INF中打开dubbo.properties文件，修改对应wookeeper服务对应地址、端口。 修改dubbo.properties文件123dubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.admin.root.password=rootdubbo.admin.guest.password=guest 将ROOT文件放入tomcat/webapps下，替换tomcata自带的ROOT， 启动tomcat打开网址 :http://localhost:8080/ ,账户名、密码都是root ,点击服务治理-&gt;提供者，这里就可以看到dubbo发布的provider详细信息。 成功开启输入用户名密码root后，即可进入控制台首页查看消费者提供者情况： 查看提供者： 查看消费者： 阿里项目地址，有兴趣可以查看：https://github.com/apache/incubator-dubbo 参考文章：Dubbo入门—搭建一个最简单的Demo框架 dubbo系列（三）——dubbo管理工具dubbo-admin安装使用]]></content>
      <categories>
        <category>分布式框架</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>分布式框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot文件上传集成Swagger生成RESTful规范API文档]]></title>
    <url>%2FSpringBoot%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%9B%86%E6%88%90Swagger%E7%94%9F%E6%88%90RESTful%E8%A7%84%E8%8C%83API%E6%96%87%E6%A1%A3.html</url>
    <content type="text"><![CDATA[集成Swagger生成RESTful规范API文档Swagger是为了描述一套标准的而且是和语言无关的REST API的规范。对于外部调用者来说，只需通过Swagger文档即可清楚Server端提供的服务，而不需去阅读源码或接口文档说明。 官方网站：http://swagger.io中文网站：http://www.sosoapi.com 背景前后端分离 前后端仅仅通过异步接口(AJAX/JSON)来编程 前后端都各自有自己的开发流程流程，构建工具，测试集合。 关注点分离,前后端变得相对独立并且松耦合 后台编写和维护接口文档，在 API 变化时更新接口文档 后台根据接口文档进行接口开发 前端根据接口文档进行开发 开发完成后联调和提交测试 Spring Boot整合Swagger21、修改pom.xml,添加Swagger2依赖12345678910111213&lt;!-- Swagger2--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--接口API生成html文档--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 2、编写Swagger2配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * 〈一句话功能简述〉&lt;br&gt; * 〈通过@Configuration注解 让Spring来加载该类配置〉 * 〈通过@EnableSwagger2注解启用Swagger2〉 * @author Raven * @create 2018/8/6 1125 * @since 1.0.0 */@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket createRestApi()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //为当前包路径 .apis(RequestHandlerSelectors.basePackage("com.raven.upload.controller")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() //页面标题 .title("springBoot文件上传平台--基数数据API说明文档") //创建人 .contact(new Contact("Raven","http://www.syraven.top","sy759770423@163.com")) //描述 .description("2018.8.6上线版本") //.termsOfServiceUrl("http://syraven.top") //版本号 .version("1.0") .build(); &#125;&#125; 通过@Configuration注解，让Spring来加载该类配置 通过@EnableSwagger2注解来启用Swagger2。 再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore注解的API）。 3、编写Controller这里开始编写自己的RESTful Controller，跟正常开发没什么区别。主要是接口方法上面新增了几个注解： 通过@ApiOperation注解来给API增加说明 通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明 通过@ApiIgnore来忽略那些不想让生成RESTful API文档的接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.raven.upload.controller;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.UUID;/** * 〈一句话功能简述〉&lt;br&gt; * 〈〉 * * @author Raven * @create 2018/7/24 0024 * @since 1.0.0 */@RestController@RequestMapping("/file")@Validated@Api(value = "文件上传UploadController",tags = &#123;"文件上传"&#125;)public class UploadController &#123; /** * 初始化上传文件界面,跳转到index.jsp * * @return */ @ApiOperation(value = "初始化上传界面",notes = "上传界面") //@GetMapping(value = "/index") @RequestMapping(value = "/index", method = RequestMethod.GET) public String index() &#123; return "index"; &#125; /** * 上传文方法 * @param file 前台上传的文件对象 * @return */ @RequestMapping(value = "/upload", method = RequestMethod.POST) //@PostMapping(value = "/upload") @ApiOperation(value = "上传单张图片接口",notes = "上传单张图片接口") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "header",dataType = "string",name = "token",value = "访问凭证",required = true), &#125;) public @ResponseBody String upload(HttpServletRequest request, MultipartFile file) &#123; try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/") + "upload/"; //如果目录不存在，自动创建文件夹 File dir = new File(uploadDir); if (!dir.exists()) &#123; dir.mkdir(); &#125; /** //文件后缀名 String suttix = file.getOriginalFilename().substring(file.getOriginalFilename().indexOf(".")); //上传文件名 String filename = UUID.randomUUID() + suttix; //String filename = file.getOriginalFilename(); //服务器端保存的文件对象 File serverFile = new File(uploadDir + filename); //将上传的文件写入到服务器端文件内 file.transferTo(serverFile);*/ executeUpload(uploadDir,file); &#125; catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); return "上传失败"; &#125; return "上传成功"; &#125; /** * 提取上传方法为公共方法 * @param uploadDir 上传目录 * @param file 上传对象 * @throws Exception */ private void executeUpload(String uploadDir,MultipartFile file) throws Exception &#123; //文件后缀名 String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().indexOf(".")); //上传文件名 String filename = UUID.randomUUID()+suffix; //服务器端保存的文件对象 File serverFile = new File(uploadDir+filename); //将上传的文件写入到服务器端文件内 file.transferTo(serverFile); &#125; //@PostMapping(value = "/uploads") @RequestMapping(value = "/uploads",method = RequestMethod.POST) @ApiOperation(value = "上传多张图片接口",notes = "上传多张图片接口") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "header",dataType = "string",name = "token",value = "访问凭证",required = true), &#125;) public @ResponseBody String uploads(HttpServletRequest request,MultipartFile[] file)&#123; try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/")+"upload/"; //如果目录不存在，自动创建文件夹 File dir = new File(uploadDir); if (!dir.exists())&#123; dir.mkdir(); &#125; //遍历数组执行上传 for (int i = 0; i &lt;file.length ; i++) &#123; if(file[i]!=null)&#123; //调用上传方法 executeUpload(uploadDir,file[i]); &#125; &#125; &#125; catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); return "上传失败"; &#125; return "上传成功"; &#125;&#125; 完成上述代码后，打包Spring Boot程序并启动，打开浏览器访问：http://localhost:8080/swagger-ui.html，就能看到前文所展示的RESTful API的页面。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger生成RESTful规范API文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决CentOS服务器 命令登录MySQL时，报错ERROR]]></title>
    <url>%2FMySql%20Erro.html</url>
    <content type="text"><![CDATA[解决CentOS 命令登录MySQL时，报错ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES) 错误解决方法1.停用mysql# /etc/rc.d/init.d/mysqld stop2.输入命令#mysqld_safe –user=mysql –skip-grant-tables –skip-networking &amp;或者修改配置文件 ####在mysql安装根目录下找到my.cnf, 打开刚才我们找到的配置文件，然后在里面找到 [mysqld] 这一项，然后在该配置项下添加 skip-grant-tables 这个配置，然后保存文件。 3.登入数据库#mysql -u root mysql;#mysql -u root -p;密码为空，直接回车就好 4.mysql&gt;use mysql;结果如下：Database changed5.mysql&gt; UPDATE user SET Password=PASSWORD(‘newpassword’)where USER=’newuser’;例如给root设置新密码：UPDATE user SET Password=PASSWORD(‘123456’)where USER=’root’; mysql&gt;FLUSH PRIVILEGES;mysql&gt; quit 6.最后重启mysql#/etc/init.d/mysqld restart]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次使用druid数据库连接池遇到的Bug]]></title>
    <url>%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%81%87%E5%88%B0Bug.html</url>
    <content type="text"><![CDATA[具体的错误代码为： 123456org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Access denied for user 'YuSong'@'localhost' (using password: YES)### The error may exist in file [D:\代码仓库\SsmRaven\target\classes\mapper\UserDao.xml]### The error may involve com.syRaven.dao.IUserDao.selectUser### The error occurred while executing a query### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Access denied for user 'YuSong'@'localhost' (using password: YES) java.sql.SQLException: Access denied for user ‘YuSong‘@’localhost’ (using password: YES)使用的是MySQL数据库，使用druid连接池访问数据库失败。看报错的代码的意思是：ava.sql.SQLException：拒绝用户‘YuSong‘@’localhost’的访问（使用password：YES） 观察这个错误代码发现数据库的用户名是我的电脑主机名，并不是jdbc.properties中设置的root. 数据库拒绝访问，我表示很蛋疼，因为数据库的用户名为root，而且也经过测试，通过root是可以连接到数据库的，为什么出来的是本机名YuSong？ 后来经过查询，在Spring完成注入时是用 “${..}” 方式获取值完成注入的。而通过这种表达式也能直接获取到JVM系统属性。 因为在系统中也有个username属性，这时系统变量覆盖了Properties中的值，这时取得username的值为系统的用户名Administrator（YuSong），密码为properties中的password去查询数据库，此时用户名名和密码并不匹配就会报错。 1、将jdbc.properties文件中的username名称换为其他不冲突的字符，比如user。2、在Spring配置文件中修改成：&lt;context:property-placeholder location=”classpath:/jdbc.properties” system-properties-mode=”FALLBACK / NEVER”/&gt; 添加一个system-properties-mode属性 该属性有三个值：FALLBACK — 默认值，不存在时覆盖 NEVER — 不覆盖 OVERRIDE — 覆盖 This link:[https://blog.csdn.net/qq_35181209/article/details/79497786][https://www.cnblogs.com/tongxuping/p/7081656.html]]]></content>
      <categories>
        <category>java技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>ddruid数据库连接池</tag>
        <tag>Bug积累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode系列之数据库]]></title>
    <url>%2FLeetCode%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
    <content type="text"><![CDATA[第二高的薪水–sql查询LEETCODE题目：(2)编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述 Employee表，SQL查询应该返回200作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ MySQL : 方法:1select max(Salary) as SecondHighestSalary from Employee where Salary&lt;(select max(Salary) from Employee); 第一种方法select max(Salary) from Employee 先找出最高的工资。将最高工资作为条件，从小于最高工资中找最高的工资，找出来就是第二高的工资。具体执行结果，如下图：]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题总结]]></title>
    <url>%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[一些常见面试题 1、说说&amp;和&amp;&amp;的区别&emsp;&emsp; &amp;&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符俩变得表达式的结果都为true时，结果才为true，否则，只要一方为false，则结果为false。区别是&amp;&amp;只要满足第一个条件，后面条件就不再判断。而&amp;要对所有的条件都进行判断。 &emsp;&emsp;&amp;&amp;为短路与，即如果第一个表达式为false，则不再判断第二个表达式了。例如if(str!=null &amp;&amp; !str.equals(s))表达式，当str为null时，后面的的表达式为false，不会再执行了，所以不会出现NullPointerException异常。如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。 2、Integer与int的区别 &emsp;&emsp; int是java提供的8种原始数据类型之一。java为每个原始类提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。 &emsp;&emsp;例如：要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。 &emsp;&emsp;在Hibernate框架中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。 &emsp;&emsp;另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。 3、抽象类（abstractclass）和接口（interface）有什么区别？ 抽象类可以有构造方法，接口不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量。 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类可以是public，protected和（默认类型，虽然eclipese下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 抽象类中可以包含静态方法，接口中不能包含静态方法。 抽象类和接口中可以包含静态成员变量，抽象类中的静态成员变量的访问类可以任意，接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 一个类可以实现多个接口，但只能继承一个抽象类。]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap和HashMap的比较使用]]></title>
    <url>%2FLinkedHashMap%E5%92%8CHashMap%E7%9A%84%E6%AF%94%E8%BE%83%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[前几天在Java知音看到这篇文章，刚好出去面试的时候被问到很多次HashMap和LinkedHashMap，就做个记录。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashMap;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.Map;/** * 〈一句话功能简述〉&lt;br&gt; * 〈〉 * * @author YuSong * @create 2018/6/4 * @since 1.0.0 */public class TestLinkedHashMap &#123; public static void main(String[] args)&#123; System.out.println("******LinkedHashMap******"); Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;Integer, String&gt;(); map.put(6,"apple"); map.put(3,"banana"); map.put(2,"pear"); map.put(null,"orange"); for(Iterator it = map.keySet().iterator();it.hasNext();) &#123; Object key = it.next(); System.out.println(key+"="+map.get(key)); &#125; System.out.println("******HashMap******"); Map&lt;Integer,String&gt; map1 = new HashMap&lt;Integer, String&gt;(); map1.put(6,"apple"); map1.put(3,"banana"); map1.put(2,"pear"); map1.put(null,""); for (Iterator it = map1.keySet().iterator();it.hasNext();) &#123; Object key = it.next(); System.out.println(key+"="+map1.get(key)); &#125; &#125;&#125; 运行结果如下：12345678910******LinkedHashMap******6=apple3=banana2=pearnull=orange******HashMap******null=2=pear3=banana6=apple 分析：LinkedHashMap 的特点是put进去的对象位置未发生变化,而HashMap会发生变化。java为数据结构中的映射定义了一个Map接口，Java 中的 Map 接口是和 Collection接口同一等级的集合根接口，它表示一个键值对 (key-value) 的映射。Map的实现类主要有4种: Hashtable 古老，线程安全 HashMap 速度很快，但没有顺序，非线程安全 TreeMap 有序的，效率比HashMap低 LinkedHashMap 结合HashMap和TreeMap的优点，有序的同时效率也不错仅比HashMap慢一点 按照效率排序的话：HashMap &gt; LinkedHashMap &gt; TreeMap &gt; Hashtable Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了)，但允许值重复。Hashmap 是一个最常用的Map，它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为Null。 HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。 Hashtable与 HashMap类似，它继承自Dictionary类，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了 Hashtable在写入时会比较慢。 LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。 一般情况下，我们用的最多的是HashMap，在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同，那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列。 HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。 HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。 在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。 ThanksLinkedHashMap和HashMap的比较使用 Java 集合深入理解（14）：Map 概述]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown的用法]]></title>
    <url>%2Fexcho.html</url>
    <content type="text"><![CDATA[Markdown的使用语法 Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ###定义列表 Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' ###脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 ##浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
